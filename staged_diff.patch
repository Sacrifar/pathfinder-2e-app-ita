diff --git a/src/components/common/GlobalDiceDisplay.tsx b/src/components/common/GlobalDiceDisplay.tsx
index 08ae176c..e6635bfd 100644
--- a/src/components/common/GlobalDiceDisplay.tsx
+++ b/src/components/common/GlobalDiceDisplay.tsx
@@ -25,28 +25,43 @@ function extractElementFromTraits(traits: string[]): string | undefined {
 
 /**
  * Element color mapping for 3D dice
+ * Colors match the impulse panel (ImpulsePanel.tsx) for consistency
  * Each element has a primary color (for base dice) and a bonus color (for extra damage dice)
- * Includes both kineticist elements and spell damage traits
+ * Includes kineticist elements, spell damage traits, and weapon rune damage types
  */
 const ELEMENT_COLORS: Record<string, { primary: string; bonus: string }> = {
-    // Kineticist elements
-    air: { primary: '#3B82F6', bonus: '#FBBF24' },      // Blue (base) + Yellow (electricity)
-    fire: { primary: '#EF4444', bonus: '#F97316' },     // Red (base) + Orange (bonus)
-    earth: { primary: '#78716C', bonus: '#22C55E' },    // Brown (base) + Green (bonus)
-    metal: { primary: '#6B7280', bonus: '#EAB308' },    // Gray (base) + Gold (bonus)
-    water: { primary: '#0EA5E9', bonus: '#06B6D4' },    // Light Blue (base) + Cyan (bonus)
-    wood: { primary: '#854D0E', bonus: '#DC2626' },     // Brown (base) + Red (fire bonus)
-
-    // Spell damage traits
+    // Kineticist elements (colors from ImpulsePanel.tsx getElementColor)
+    air: { primary: '#87CEEB', bonus: '#FBBF24' },      // Sky Blue (base) + Yellow (electricity)
+    fire: { primary: '#FF4500', bonus: '#F97316' },     // Orange Red (base) + Orange (bonus)
+    earth: { primary: '#8B4513', bonus: '#22C55E' },    // Saddle Brown (base) + Green (bonus)
+    metal: { primary: '#C0C0C0', bonus: '#EAB308' },    // Silver (base) + Gold (bonus)
+    water: { primary: '#1E90FF', bonus: '#06B6D4' },    // Dodger Blue (base) + Cyan (bonus)
+    wood: { primary: '#228B22', bonus: '#DC2626' },     // Forest Green (base) + Red (fire bonus)
+    aether: { primary: '#9370DB', bonus: '#A855F7' },   // Medium Purple (base) + Light Purple (bonus)
+    void: { primary: '#2F4F4F', bonus: '#374151' },     // Dark Slate Gray (base) + Gray (bonus)
+
+    // Spell damage traits and weapon rune elements
     electricity: { primary: '#FBBF24', bonus: '#FDE047' }, // Yellow + Light Yellow
     cold: { primary: '#06B6D4', bonus: '#67E8F9' },      // Cyan + Light Cyan
-    acid: { primary: '#84CC16', bonus: '#A3E635' },      // Green + Light Green
+    acid: { primary: '#2ecc71', bonus: '#A3E635' },      // Green + Light Green (matches DamageBreakdown)
     poison: { primary: '#A855F7', bonus: '#C084FC' },     // Purple + Light Purple
-    sonic: { primary: '#F97316', bonus: '#FB923C' },      // Orange + Light Orange
-    force: { primary: '#E5E7EB', bonus: '#F3F4F6' },     // Gray + Light Gray
-    vitality: { primary: '#F472B6', bonus: '#F9A8D4' },   // Pink + Light Pink
-    void: { primary: '#1F2937', bonus: '#374151' },      // Dark Gray + Gray
-    chaos: { primary: '#7C3AED', bonus: '#8B5CF6' },     // Violet + Purple
+    sonic: { primary: '#9b59b6', bonus: '#BB8DBF' },      // Purple + Light Purple (matches DamageBreakdown)
+    force: { primary: '#95a5a6', bonus: '#BDC3C7' },     // Gray + Light Gray (matches DamageBreakdown)
+    vitality: { primary: '#ff69b4', bonus: '#F9A8D4' },   // Hot Pink + Light Pink (matches DamageBreakdown)
+
+    // Spirit damage (holy/unholy runes)
+    spirit: { primary: '#dda0dd', bonus: '#E6B8E6' },     // Plum + Light Plum (matches DamageBreakdown)
+    holy: { primary: '#ffd700', bonus: '#FFEC8B' },      // Gold + Light Gold (matches DamageBreakdown)
+    unholy: { primary: '#4b0082', bonus: '#6A0DAD' },    // Indigo + Purple (matches DamageBreakdown)
+
+    // Alignment damage (axiomatic/anarchic runes)
+    chaotic: { primary: '#7C3AED', bonus: '#8B5CF6' },   // Violet + Purple
+    lawful: { primary: '#3B82F6', bonus: '#60A5FA' },    // Blue + Light Blue
+
+    // Other damage types (weapon runes)
+    positive: { primary: '#f5f5dc', bonus: '#FFFACD' },  // Beige + Lemon Chiffon (matches DamageBreakdown)
+    negative: { primary: '#8b0000', bonus: '#A52A2A' },  // Dark Red + Brown (matches DamageBreakdown)
+    bleed: { primary: '#8b0000', bonus: '#A52A2A' },     // Dark Red + Brown (matches DamageBreakdown)
 
     // Physical damage types
     precision: { primary: '#14B8A6', bonus: '#5EEAD4' }, // Teal + Light Teal
@@ -76,8 +91,17 @@ function isD20CheckRoll(roll: { rolls: Array<{ sides: number; count: number }> }
  * Helper function to roll multiple dice types using DiceBox's roll method.
  * Supports Roll Objects with themeColor for elemental dice coloring.
  * For "4d6+1d12+6", we extract dice notations and pass them as Roll Objects with colors.
+ *
+ * @param elementalTypes Optional array of elemental types for multi-colored runes (e.g., ['fire', 'cold', 'acid'])
+ * @param elementalRunesMode If true, only color subsequent dice (elemental damage), not the first group (base weapon damage)
  */
-function rollWithDiceBox(diceBox: DiceBox, formula: string, element?: string) {
+function rollWithDiceBox(
+    diceBox: DiceBox,
+    formula: string,
+    element?: string,
+    elementalRunesMode?: boolean,
+    elementalTypes?: string[]
+) {
     const cleanFormula = formula.replace(/\s+/g, '').toLowerCase();
     const diceRegex = /(\d+)d(\d+)/gi;
     const rollObjects: Array<{ qty: number; sides: number; themeColor?: string }> = [];
@@ -94,22 +118,57 @@ function rollWithDiceBox(diceBox: DiceBox, formula: string, element?: string) {
         return;
     }
 
-    // If we have element info, apply colors
-    // First group of dice gets primary color, subsequent groups get bonus color
-    if (element && ELEMENT_COLORS[element]) {
+    console.log('[rollWithDiceBox]', {
+        formula,
+        element,
+        elementalTypes,
+        elementalRunesMode,
+        rollObjects: JSON.parse(JSON.stringify(rollObjects)),
+        colorsAvailable: element ? ELEMENT_COLORS[element] : undefined
+    });
+
+    // If we have elemental types array, use per-die coloring (for weapon runes)
+    if (elementalTypes && elementalTypes.length > 0) {
+        // First die group is base weapon damage (uncolored or damage type color)
+        // Subsequent groups are elemental runes with their specific colors
+        rollObjects.forEach((obj, index) => {
+            if (index === 0) {
+                // Base weapon damage - no color (use default)
+                // Optionally could use damage type color here
+            } else if (index - 1 < elementalTypes.length) {
+                // Each elemental rune gets its specific color
+                const elementType = elementalTypes[index - 1];
+                const colorData = ELEMENT_COLORS[elementType];
+                if (colorData) {
+                    obj.themeColor = colorData.primary;
+                }
+            }
+        });
+    }
+    // Legacy behavior: single element for all dice
+    else if (element && ELEMENT_COLORS[element]) {
         const colors = ELEMENT_COLORS[element];
 
         rollObjects.forEach((obj, index) => {
-            if (index === 0) {
-                // Primary dice (base damage) - primary color
-                obj.themeColor = colors.primary;
+            if (elementalRunesMode) {
+                // For weapon runes: only color elemental dice (index > 0), leave base damage uncolored
+                if (index > 0) {
+                    obj.themeColor = colors.primary;
+                }
+                // First group (base weapon damage) stays uncolored (default)
             } else {
-                // Bonus dice (extra damage from stances/feats) - bonus color
-                obj.themeColor = colors.bonus;
+                // For elemental blast and stances: first group gets primary, rest get bonus
+                if (index === 0) {
+                    obj.themeColor = colors.primary;
+                } else {
+                    obj.themeColor = colors.bonus;
+                }
             }
         });
     }
 
+    console.log('[rollWithDiceBox] Final rollObjects:', JSON.parse(JSON.stringify(rollObjects)));
+
     // Roll all dice at once using Roll Objects
     diceBox.roll(rollObjects);
 }
@@ -177,9 +236,13 @@ export function GlobalDiceDisplay() {
                 // Roll any pending dice after initialization
                 if (rolls.length > 0) {
                     const latestRoll = rolls[rolls.length - 1];
-                    console.log('[GlobalDiceDisplay] Rolling with formula:', latestRoll.formula);
+                    console.log('[GlobalDiceDisplay] Rolling with formula:', latestRoll.formula, 'element:', latestRoll.element, 'weaponData:', latestRoll.weaponData);
                     setTimeout(() => {
-                        rollWithDiceBox(diceBox, latestRoll.formula, latestRoll.element);
+                        // For weapons with elemental runes, use elementalRunesMode to only color elemental dice
+                        const elementalRunesMode = latestRoll.weaponData !== undefined && latestRoll.element !== undefined;
+                        const elementalTypes = latestRoll.weaponData?.elementalTypes;
+                        console.log('[GlobalDiceDisplay] elementalRunesMode:', elementalRunesMode, 'elementalTypes:', elementalTypes);
+                        rollWithDiceBox(diceBox, latestRoll.formula, latestRoll.element, elementalRunesMode, elementalTypes);
                     }, 300);
                 }
             }).catch(err => {
@@ -202,9 +265,13 @@ export function GlobalDiceDisplay() {
                 // Roll 3D dice if initialized
                 if (diceBoxRef.current && isInitialized) {
                     setTimeout(() => {
-                        console.log('[GlobalDiceDisplay] Rolling with formula:', latestRoll.formula);
+                        console.log('[GlobalDiceDisplay] Rolling with formula:', latestRoll.formula, 'element:', latestRoll.element, 'weaponData:', latestRoll.weaponData);
                         if (diceBoxRef.current) {
-                            rollWithDiceBox(diceBoxRef.current, latestRoll.formula, latestRoll.element);
+                            // For weapons with elemental runes, use elementalRunesMode to only color elemental dice
+                            const elementalRunesMode = latestRoll.weaponData !== undefined && latestRoll.element !== undefined;
+                            const elementalTypes = latestRoll.weaponData?.elementalTypes;
+                            console.log('[GlobalDiceDisplay] elementalRunesMode:', elementalRunesMode, 'elementalTypes:', elementalTypes);
+                            rollWithDiceBox(diceBoxRef.current, latestRoll.formula, latestRoll.element, elementalRunesMode, elementalTypes);
                         }
                     }, 300);
                 }
@@ -260,14 +327,16 @@ export function GlobalDiceDisplay() {
         const attackBonus = weaponData.attackBonus - mapPenalty;
         const formula = `1d20${attackBonus >= 0 ? '+' : ''}${attackBonus}`;
         const label = `${t('weapons.attack') || 'Attack'}: ${weaponData.weaponName}${attackNumber > 1 ? ` (${attackNumber})` : ''}`;
-        rollDice(formula, label, { weaponData });
+        // Pass element from weaponData if available (for elemental rune dice coloring)
+        rollDice(formula, label, { weaponData, element: weaponData.element });
     };
 
     // Handle weapon damage roll
     const handleWeaponDamageRoll = (weaponData: WeaponRollData, doubleDamage: boolean = false) => {
         const formula = doubleDamage ? doubleDamageFormula(weaponData.damage) : weaponData.damage;
         const label = `${t('weapons.damageRoll') || 'Damage'}: ${weaponData.weaponName}${doubleDamage ? ' (Critical)' : ''}`;
-        rollDice(formula, label, { weaponData });
+        // Pass element from weaponData if available (for elemental rune dice coloring)
+        rollDice(formula, label, { weaponData, element: weaponData.element });
     };
 
     // Handle impulse attack roll with MAP
diff --git a/src/components/desktop/DamageBreakdown.tsx b/src/components/desktop/DamageBreakdown.tsx
new file mode 100644
index 00000000..f5550148
--- /dev/null
+++ b/src/components/desktop/DamageBreakdown.tsx
@@ -0,0 +1,214 @@
+import React from 'react';
+import { useLanguage } from '../../hooks/useLanguage';
+import { DamageComponent, DamageBreakdown as DamageBreakdownType } from '../../utils/damageBreakdown';
+
+interface DamageBreakdownProps {
+    breakdown: DamageBreakdownType;
+    onToggleConditional?: (conditionalId: string) => void;
+    compact?: boolean;  // If true, show compact view (inline with damage)
+}
+
+export const DamageBreakdown: React.FC<DamageBreakdownProps> = ({
+    breakdown,
+    onToggleConditional,
+    compact = false,
+}) => {
+    const { t, language } = useLanguage();
+
+    const getLabel = (comp: DamageComponent) => {
+        return language === 'it' && comp.labelIt ? comp.labelIt : comp.label;
+    };
+
+    const getDamageTypeColor = (type?: string) => {
+        if (!type) return '';
+        const colors: Record<string, string> = {
+            'physical': '',
+            'slashing': '#e74c3c',
+            'piercing': '#e67e22',
+            'bludgeoning': '#f39c12',
+            'fire': '#e74c3c',
+            'cold': '#3498db',
+            'electricity': '#f1c40f',
+            'acid': '#2ecc71',
+            'sonic': '#9b59b6',
+            'force': '#95a5a6',
+            'positive': '#f5f5dc',
+            'negative': '#8b0000',
+            'holy': '#ffd700',
+            'unholy': '#4b0082',
+            'spirit': '#dda0dd',
+            'bleed': '#8b0000',
+            'vitality': '#ff69b4',
+        };
+        return colors[type.toLowerCase()] || '';
+    };
+
+    const hasContent = breakdown.base.length > 0 ||
+        breakdown.runes.length > 0 ||
+        breakdown.modifier.length > 0 ||
+        breakdown.buffs.length > 0 ||
+        breakdown.conditional.length > 0;
+
+    if (!hasContent) {
+        return null;
+    }
+
+    // Compact view: show inline summary
+    if (compact) {
+        const allParts = [
+            ...breakdown.base,
+            ...breakdown.runes.filter(r => r.isActive !== false),
+            ...breakdown.modifier,
+            ...breakdown.buffs,
+        ];
+
+        return (
+            <span className="damage-breakdown-compact">
+                {allParts.map((part, idx) => (
+                    <span
+                        key={idx}
+                        className="damage-part"
+                        style={{ color: getDamageTypeColor(part.damageType) }}
+                        title={`${getLabel(part)}: ${part.value}`}
+                    >
+                        {part.value}
+                    </span>
+                ))}
+            </span>
+        );
+    }
+
+    // Full view: show detailed breakdown with checkboxes
+    return (
+        <div className="damage-breakdown">
+            {/* Base Damage */}
+            {breakdown.base.length > 0 && (
+                <div className="damage-section">
+                    <span className="damage-section-title">
+                        {t('damage.base') || 'Base'}
+                    </span>
+                    {breakdown.base.map((comp, idx) => (
+                        <span
+                            key={idx}
+                            className="damage-component"
+                            style={{ color: getDamageTypeColor(comp.damageType) }}
+                        >
+                            {comp.value}
+                        </span>
+                    ))}
+                </div>
+            )}
+
+            {/* Runes */}
+            {breakdown.runes.length > 0 && (
+                <div className="damage-section">
+                    <span className="damage-section-title">
+                        {t('damage.runes') || 'Runes'}
+                    </span>
+                    {breakdown.runes.map((comp, idx) => {
+                        const isConditional = comp.conditionalId !== undefined;
+                        return (
+                            <span
+                                key={idx}
+                                className={`damage-component ${isConditional ? 'conditional' : ''} ${comp.isActive === false ? 'inactive' : ''}`}
+                                style={{ color: getDamageTypeColor(comp.damageType) }}
+                                title={`${getLabel(comp)}${comp.source ? ` (${comp.source})` : ''}`}
+                            >
+                                {comp.value}
+                                {isConditional && onToggleConditional && (
+                                    <input
+                                        type="checkbox"
+                                        checked={comp.isActive !== false}
+                                        onChange={(e) => {
+                                            e.stopPropagation();
+                                            if (comp.conditionalId) {
+                                                onToggleConditional(comp.conditionalId);
+                                            }
+                                        }}
+                                        className="damage-checkbox"
+                                        onClick={(e) => e.stopPropagation()}
+                                    />
+                                )}
+                            </span>
+                        );
+                    })}
+                </div>
+            )}
+
+            {/* Modifiers */}
+            {breakdown.modifier.length > 0 && (
+                <div className="damage-section">
+                    <span className="damage-section-title">
+                        {t('damage.modifiers') || 'Modifiers'}
+                    </span>
+                    {breakdown.modifier.map((comp, idx) => (
+                        <span
+                            key={idx}
+                            className="damage-component modifier"
+                            style={{ color: getDamageTypeColor(comp.damageType) }}
+                            title={getLabel(comp)}
+                        >
+                            {comp.value}
+                        </span>
+                    ))}
+                </div>
+            )}
+
+            {/* Buffs */}
+            {breakdown.buffs.length > 0 && (
+                <div className="damage-section">
+                    <span className="damage-section-title">
+                        {t('damage.buffs') || 'Buffs'}
+                    </span>
+                    {breakdown.buffs.map((comp, idx) => (
+                        <span
+                            key={idx}
+                            className="damage-component buff"
+                            style={{ color: getDamageTypeColor(comp.damageType) }}
+                            title={getLabel(comp)}
+                        >
+                            {comp.value}
+                        </span>
+                    ))}
+                </div>
+            )}
+
+            {/* Conditional Damage */}
+            {breakdown.conditional.length > 0 && (
+                <div className="damage-section conditional-section">
+                    <span className="damage-section-title">
+                        {t('damage.conditional') || 'Conditional'}
+                    </span>
+                    {breakdown.conditional.map((comp, idx) => (
+                        <label
+                            key={idx}
+                            className={`damage-component conditional ${comp.isActive ? 'active' : 'inactive'}`}
+                            style={{ color: comp.isActive ? getDamageTypeColor(comp.damageType) : '#666' }}
+                        >
+                            <input
+                                type="checkbox"
+                                checked={comp.isActive}
+                                onChange={() => onToggleConditional?.(comp.conditionalId!)}
+                                className="damage-checkbox"
+                            />
+                            <span className="conditional-damage-text">
+                                <span className="conditional-value">{comp.value}</span>
+                                <span className="conditional-label">{getLabel(comp)}</span>
+                            </span>
+                        </label>
+                    ))}
+                </div>
+            )}
+
+            {/* Total */}
+            {breakdown.total && (
+                <div className="damage-total">
+                    <span className="damage-total-label">{t('damage.total') || 'Total'}:</span>
+                    <span className="damage-total-value">{breakdown.total}</span>
+                </div>
+            )}
+        </div>
+    );
+};
+
+export default DamageBreakdown;
diff --git a/src/components/desktop/WeaponsPanel.tsx b/src/components/desktop/WeaponsPanel.tsx
index 38c1d72a..011cfcdb 100644
--- a/src/components/desktop/WeaponsPanel.tsx
+++ b/src/components/desktop/WeaponsPanel.tsx
@@ -1,15 +1,24 @@
-import React, { useState, useMemo } from 'react';
+import React, { useState, useMemo, useCallback } from 'react';
 import { useLanguage } from '../../hooks/useLanguage';
 import { useDiceRoller } from '../../hooks/useDiceRoller';
 import { Character, EquippedItem, WeaponCustomization, WeaponRunes } from '../../types';
 import { getWeapons, LoadedWeapon } from '../../data/pf2e-loader';
-import { calculateWeaponDamage, getAbilityModifier, getWeaponProficiencyRank, calculateProficiencyBonusWithVariant, ProficiencyRank } from '../../utils/pf2e-math';
+import { getAbilityModifier, getWeaponProficiencyRank, calculateProficiencyBonusWithVariant, ProficiencyRank } from '../../utils/pf2e-math';
 import { WeaponOptionsModal } from './WeaponOptionsModal';
 import { getEnhancedWeaponName } from '../../utils/weaponName';
 import { getTactics } from '../../data/tactics';
 import { ActionIcon } from '../../utils/actionIcons';
 import { WeaponRollData } from '../../types/dice';
 import { canAfford, deductCurrency, formatCurrency } from '../../utils/currency';
+import { calculateDamageBreakdown } from '../../utils/damageBreakdown';
+import { DamageBreakdown } from './DamageBreakdown';
+import {
+    calculateMAP,
+    formatAttackWithMAP,
+    hasTwoHandTrait,
+} from '../../utils/weaponCalculations';
+import { calculateWeaponDamage } from '../../utils/pf2e-math';
+import { PROPERTY_RUNES } from '../../data/weaponRunes';
 
 interface WeaponsPanelProps {
     character: Character;
@@ -37,10 +46,15 @@ export const WeaponsPanel: React.FC<WeaponsPanelProps> = ({
     // Track which weapons are two-handed (for two-hand-d* trait)
     const [twoHandedWeapons, setTwoHandedWeapons] = useState<Set<string>>(new Set());
 
+    // Track which weapons have their damage breakdown expanded
+    const [expandedDamageBreakdown, setExpandedDamageBreakdown] = useState<Set<string>>(new Set());
+
     // Load all weapons from pf2e data
     const allWeapons = useMemo(() => getWeapons(), []);
 
-    // Filter weapons based on search and category
+    // Filter weapons based on search and category (optimized with search normalization)
+    const searchQueryNormalized = useMemo(() => searchQuery.toLowerCase().trim(), [searchQuery]);
+
     const filteredWeapons = useMemo(() => {
         let weapons = allWeapons;
 
@@ -49,26 +63,20 @@ export const WeaponsPanel: React.FC<WeaponsPanelProps> = ({
             weapons = weapons.filter(w => w.category === categoryFilter);
         }
 
-        // Filter by search
-        if (searchQuery) {
-            const q = searchQuery.toLowerCase();
+        // Filter by search (optimized with pre-lowercased query)
+        if (searchQueryNormalized) {
             weapons = weapons.filter(w =>
-                w.name.toLowerCase().includes(q) ||
-                w.traits.some(t => t.toLowerCase().includes(q)) ||
-                w.group.toLowerCase().includes(q)
+                w.name.toLowerCase().includes(searchQueryNormalized) ||
+                w.traits.some(t => t.toLowerCase().includes(searchQueryNormalized)) ||
+                w.group.toLowerCase().includes(searchQueryNormalized)
             );
         }
 
         return weapons.slice(0, 50); // Limit for performance
-    }, [allWeapons, categoryFilter, searchQuery]);
+    }, [allWeapons, categoryFilter, searchQueryNormalized]);
 
-    // Check if weapon has two-hand-d* trait
-    const hasTwoHandTrait = (weapon: LoadedWeapon) => {
-        return weapon.traits.some(t => t.startsWith('two-hand-d'));
-    };
-
-    // Toggle two-handed mode for a weapon
-    const toggleTwoHand = (weaponId: string) => {
+    // Toggle handlers - optimized with useCallback to prevent unnecessary re-renders
+    const toggleTwoHand = useCallback((weaponId: string) => {
         setTwoHandedWeapons(prev => {
             const newSet = new Set(prev);
             if (newSet.has(weaponId)) {
@@ -78,83 +86,203 @@ export const WeaponsPanel: React.FC<WeaponsPanelProps> = ({
             }
             return newSet;
         });
-    };
+    }, []);
 
-    // Calculate attack bonus for a weapon
-    const calculateAttackBonus = (weapon: LoadedWeapon, mapPenalty: number = 0): number => {
-        const strMod = getAbilityModifier(character.abilityScores.str);
+    const toggleDamageBreakdown = useCallback((weaponId: string) => {
+        setExpandedDamageBreakdown(prev => {
+            const newSet = new Set(prev);
+            if (newSet.has(weaponId)) {
+                newSet.delete(weaponId);
+            } else {
+                newSet.add(weaponId);
+            }
+            return newSet;
+        });
+    }, []);
 
-        // Get weapon proficiency rank as enum
-        const profRank = getWeaponProficiencyRank(character, weapon.category);
+    const toggleConditionalDamage = useCallback((conditionalId: string) => {
+        const currentActive = character.activeConditionalDamage || [];
+        const isActive = currentActive.includes(conditionalId);
+        const newActive = isActive
+            ? currentActive.filter(id => id !== conditionalId)
+            : [...currentActive, conditionalId];
 
-        const profBonus = calculateProficiencyBonusWithVariant(
-            character.level,
-            profRank,
-            character.variantRules?.proficiencyWithoutLevel
-        );
+        onCharacterUpdate({
+            ...character,
+            activeConditionalDamage: newActive,
+        });
+    }, [character.activeConditionalDamage, onCharacterUpdate]);
+
+    // Memoized proficiency calculations for all weapon categories
+    const proficiencyCalculations = useMemo(() => {
+        const categories = ['simple', 'martial', 'advanced', 'unarmed'] as const;
+        return categories.reduce((acc, category) => {
+            const profRank = getWeaponProficiencyRank(character, category);
+            const profBonus = calculateProficiencyBonusWithVariant(
+                character.level,
+                profRank,
+                character.variantRules?.proficiencyWithoutLevel
+            );
+            acc[category] = { rank: profRank, bonus: profBonus };
+            return acc;
+        }, {} as Record<string, { rank: ProficiencyRank; bonus: number }>);
+    }, [character.level, character.variantRules?.proficiencyWithoutLevel, character.weaponProficiencies]);
+
+    // Calculate attack bonus for a weapon (optimized, uses memoized proficiency)
+    const calculateAttackBonus = useCallback((weapon: LoadedWeapon, mapPenalty: number = 0): number => {
+        const strMod = getAbilityModifier(character.abilityScores.str);
+        const profData = proficiencyCalculations[weapon.category];
+        const profBonus = profData?.bonus ?? 0;
 
         // Check for potency rune bonus
         let itemBonus = 0;
         const equippedWeapon = character.equipment?.find(e => e.id === weapon.id);
         if (equippedWeapon?.runes) {
-            const runes = equippedWeapon.runes as { potencyRune?: string };
-            if (runes.potencyRune === '+1') itemBonus = 1;
-            else if (runes.potencyRune === '+2') itemBonus = 2;
-            else if (runes.potencyRune === '+3') itemBonus = 3;
-            else if (runes.potencyRune === '+4 (Major)') itemBonus = 4;
-            else if (runes.potencyRune === '+5 (Greater)') itemBonus = 5;
+            const runes = equippedWeapon.runes as WeaponRunes;
+            // potencyRune is a number (1, 2, 3, 4, 5)
+            if (runes.potencyRune && typeof runes.potencyRune === 'number') {
+                itemBonus = runes.potencyRune;
+            }
         }
 
         // Check for custom attack bonus
         const customBonus = (equippedWeapon?.customization as WeaponCustomization | undefined)?.bonusAttack || 0;
 
         return strMod + profBonus + itemBonus + customBonus - mapPenalty;
-    };
+    }, [character.abilityScores.str, character.equipment, proficiencyCalculations]);
+
+    // Get elemental damage from active property runes
+    const getElementalDamage = useCallback((weaponRunes: WeaponRunes | undefined): string => {
+        if (!weaponRunes?.propertyRunes) return '';
+
+        const activeDamage = character.activeConditionalDamage || [];
+
+        const elementalDamages: string[] = [];
+        for (const runeId of weaponRunes.propertyRunes) {
+            const runeData = PROPERTY_RUNES[runeId];
+            if (runeData?.damage && activeDamage.includes(runeId)) {
+                elementalDamages.push(runeData.damage.dice);
+            }
+        }
+
+        return elementalDamages.length > 0 ? elementalDamages.join('+') : '';
+    }, [character.activeConditionalDamage]);
+
+    // Helper to get active elemental types from runes (for dice coloring)
+    const getActiveElementalTypes = useCallback((weaponRunes: WeaponRunes | undefined): string[] => {
+        if (!weaponRunes?.propertyRunes) return [];
+
+        const activeDamage = character.activeConditionalDamage || [];
+
+        const elementalTypes: string[] = [];
+        for (const runeId of weaponRunes.propertyRunes) {
+            const runeData = PROPERTY_RUNES[runeId];
+            if (runeData?.damage && activeDamage.includes(runeId)) {
+                const type = runeData.damage.type;
+                if (['fire', 'cold', 'acid', 'electricity', 'sonic'].includes(type)) {
+                    elementalTypes.push(type);
+                }
+            }
+        }
+
+        return elementalTypes;
+    }, [character.activeConditionalDamage]);
 
-    // Handle opening dicebox with weapon data
-    const handleOpenWeaponDiceBox = (weapon: LoadedWeapon, equippedItem: EquippedItem, isTwoHanded: boolean) => {
-        const weaponRunes = equippedItem.runes as { strikingRune?: string } | undefined;
+    // Handle opening dicebox with weapon data (including active elemental damage)
+    const handleOpenWeaponDiceBox = useCallback((weapon: LoadedWeapon, equippedItem: EquippedItem, isTwoHanded: boolean) => {
+        const weaponRunes = equippedItem.runes as WeaponRunes | undefined;
         const weaponCustomization = equippedItem.customization as WeaponCustomization | undefined;
-        const damage = calculateWeaponDamage(character, weapon, isTwoHanded, { runes: weaponRunes, customization: weaponCustomization });
-        const attackBonus = calculateAttackBonus(weapon, 0); // Base attack bonus without MAP
+
+        // Get base damage
+        const baseDamage = calculateWeaponDamage(character, weapon, isTwoHanded, {
+            runes: weaponRunes,
+            customization: weaponCustomization
+        });
+
+        // Get active elemental damage from runes
+        const elementalDamage = getElementalDamage(weaponRunes);
+
+        // Combine base damage with elemental damage
+        const fullDamage = elementalDamage ? `${baseDamage}+${elementalDamage}` : baseDamage;
+
+        const attackBonus = calculateAttackBonus(weapon, 0);
         const isAgile = weapon.traits.includes('agile');
 
+        // Get active elemental types for dice coloring
+        const activeElementalTypes = getActiveElementalTypes(weaponRunes);
+
         const weaponData: WeaponRollData = {
             weaponId: weapon.id,
             weaponName: weaponCustomization?.customName || weapon.name,
-            damage: damage,
+            damage: fullDamage,  // Store FULL damage including elemental runes
             damageType: weaponCustomization?.customDamageType || weapon.damageType,
             attackBonus: attackBonus,
             isTwoHanded: isTwoHanded,
             isAgile: isAgile,
+            element: activeElementalTypes.length > 0 ? activeElementalTypes[0] : undefined,  // Legacy: single element for backward compatibility
+            elementalTypes: activeElementalTypes.length > 0 ? activeElementalTypes : undefined,  // Array for per-die coloring
         };
 
-        // Open dicebox with a placeholder roll that includes weapon data
-        rollDice('1d20', `${t('weapons.attack') || 'Attack'}: ${weapon.name}`, { weaponData });
-    };
+        const rollContext: any = { weaponData };
+
+        console.log('[WeaponsPanel] Opening dicebox:', {
+            baseDamage,
+            elementalDamage,
+            fullDamage,
+            activeElementalTypes,
+            weaponData
+        });
+
+        rollDice('1d20', `${t('weapons.attack') || 'Attack'}: ${weaponData.weaponName}`, rollContext);
+    }, [character, calculateAttackBonus, getElementalDamage, getActiveElementalTypes, rollDice, t]);
+
+    // Handle damage roll - opens dicebox with weapon data and elemental damage
+    const handleDamageRoll = useCallback((weapon: LoadedWeapon, equippedItem: EquippedItem, isTwoHanded: boolean) => {
+        const weaponRunes = equippedItem.runes as WeaponRunes | undefined;
+        const weaponCustomization = equippedItem.customization as WeaponCustomization | undefined;
+
+        // Get base damage
+        const baseDamage = calculateWeaponDamage(character, weapon, isTwoHanded, {
+            runes: weaponRunes,
+            customization: weaponCustomization
+        });
+
+        // Get active elemental damage from runes
+        const elementalDamage = getElementalDamage(weaponRunes);
+
+        // Combine base damage with elemental damage
+        const fullDamage = elementalDamage ? `${baseDamage}+${elementalDamage}` : baseDamage;
 
-    // Handle damage roll - now opens dicebox with weapon data
-    const handleDamageRoll = (weapon: LoadedWeapon, isTwoHanded: boolean) => {
-        const weaponRunes = (character.equipment?.find(e => e.id === weapon.id))?.runes as { strikingRune?: string } | undefined;
-        const weaponCustomization = (character.equipment?.find(e => e.id === weapon.id))?.customization as WeaponCustomization | undefined;
-        const damage = calculateWeaponDamage(character, weapon, isTwoHanded, { runes: weaponRunes, customization: weaponCustomization });
         const attackBonus = calculateAttackBonus(weapon, 0);
         const isAgile = weapon.traits.includes('agile');
 
+        // Get active elemental types for dice coloring
+        const activeElementalTypes = getActiveElementalTypes(weaponRunes);
+
         const weaponData: WeaponRollData = {
             weaponId: weapon.id,
             weaponName: weaponCustomization?.customName || weapon.name,
-            damage: damage,
+            damage: fullDamage,  // Store FULL damage including elemental runes
             damageType: weaponCustomization?.customDamageType || weapon.damageType,
             attackBonus: attackBonus,
             isTwoHanded: isTwoHanded,
             isAgile: isAgile,
+            element: activeElementalTypes.length > 0 ? activeElementalTypes[0] : undefined,  // Legacy: single element for backward compatibility
+            elementalTypes: activeElementalTypes.length > 0 ? activeElementalTypes : undefined,  // Array for per-die coloring
         };
 
-        // Open dicebox with weapon data
-        const elementLabel = weaponCustomization?.customDamageType || weapon.damageType;
-        rollDice(damage, `${t('weapons.damageRoll') || 'Damage'}: ${weaponData.weaponName}`, { weaponData });
-    };
+        const rollContext: any = { weaponData };
+
+        console.log('[WeaponsPanel] Damage roll:', {
+            baseDamage,
+            elementalDamage,
+            fullDamage,
+            activeElementalTypes,
+            weaponData
+        });
+
+        rollDice(fullDamage, `${t('weapons.damageRoll') || 'Damage'}: ${weaponData.weaponName}`, rollContext);
+    }, [character, calculateAttackBonus, getElementalDamage, getActiveElementalTypes, rollDice, t]);
 
     // Add weapon to character's inventory (Give - free)
     const handleGiveWeapon = (weapon: LoadedWeapon) => {
@@ -509,6 +637,12 @@ export const WeaponsPanel: React.FC<WeaponsPanelProps> = ({
                         // Check if has two-hand trait
                         const hasTwoHand = hasTwoHandTrait(weapon);
 
+                        // Calculate MAP values for display
+                        const isAgile = weapon.traits.includes('agile');
+                        const mapValues = calculateMAP(isAgile);
+                        const baseAttackBonus = calculateAttackBonus(weapon, 0);
+                        const attackWithMAP = formatAttackWithMAP(baseAttackBonus, mapValues);
+
                         // Get custom name if set, otherwise generate enhanced name with runes and materials
                         const displayName = weaponCustomization?.customName ||
                             getEnhancedWeaponName(weapon.name, weaponRunes, weaponCustomization, { language });
@@ -541,9 +675,18 @@ export const WeaponsPanel: React.FC<WeaponsPanelProps> = ({
                                     </div>
                                 </div>
 
-                                {/* Attack section */}
+                                {/* Attack section with MAP display */}
                                 <div className="weapon-attack-section">
-                                    <div className="attack-label">{t('weapons.attack') || 'Attack'}</div>
+                                    <div className="attack-info-row">
+                                        <div className="attack-label">{t('weapons.attack') || 'Attack'}</div>
+                                        <div className="attack-bonus-display">
+                                            <span className="attack-bonus-label">{t('weapons.attackBonus') || 'Attack Bonus'}</span>
+                                            <span className="attack-bonus-value">{attackWithMAP}</span>
+                                            {isAgile && (
+                                                <span className="agile-indicator" title={t('weapons.agileTrait') || 'Agile: Reduced MAP penalties'}>âš¡</span>
+                                            )}
+                                        </div>
+                                    </div>
                                     <div className="weapon-controls">
                                         {/* Two-Hand Toggle */}
                                         {hasTwoHand && (
@@ -560,7 +703,7 @@ export const WeaponsPanel: React.FC<WeaponsPanelProps> = ({
                                         <button
                                             className="attack-btn main-attack"
                                             onClick={() => handleOpenWeaponDiceBox(weapon, item, isTwoHanded)}
-                                            title={t('weapons.rollAttack') || 'Roll Attack'}
+                                            title={`${t('weapons.rollAttack') || 'Roll Attack'}: +${baseAttackBonus}`}
                                         >
                                             <img src="/assets/icon_d20_orange_small.png" alt="D20" style={{ width: '20px', height: '20px' }} />
                                         </button>
@@ -569,17 +712,44 @@ export const WeaponsPanel: React.FC<WeaponsPanelProps> = ({
 
                                 {/* Damage and stats section */}
                                 <div className="weapon-stats-section">
+                                    {/* Damage row with toggle for breakdown */}
                                     <div className="weapon-stat-row">
                                         <span className="stat-label">{t('stats.damage') || 'Damage'}:</span>
-                                        <span className="stat-value">{damage} {(item.customization as WeaponCustomization | undefined)?.customDamageType || weapon.damageType}</span>
-                                        <button
-                                            className="damage-roll-btn"
-                                            onClick={() => handleDamageRoll(weapon, isTwoHanded)}
-                                            title={`${t('dice.damageRoll') || 'Damage Roll'}: ${weapon.name}`}
-                                        >
-                                            ðŸŽ²
-                                        </button>
+                                        <div className="damage-display-with-toggle">
+                                            <button
+                                                className="damage-breakdown-toggle"
+                                                onClick={() => toggleDamageBreakdown(item.id)}
+                                                title={t('damage.toggleBreakdown') || 'Toggle damage breakdown'}
+                                            >
+                                                {expandedDamageBreakdown.has(item.id) ? 'â–¼' : 'â–¶'}
+                                            </button>
+                                            <span className="stat-value">{damage} {(item.customization as WeaponCustomization | undefined)?.customDamageType || weapon.damageType}</span>
+                                            <button
+                                                className="damage-roll-btn"
+                                                onClick={() => handleDamageRoll(weapon, item, isTwoHanded)}
+                                                title={`${t('dice.damageRoll') || 'Damage Roll'}: ${weapon.name}`}
+                                            >
+                                                ðŸŽ²
+                                            </button>
+                                        </div>
                                     </div>
+
+                                    {/* Damage Breakdown (expanded) */}
+                                    {expandedDamageBreakdown.has(item.id) && (
+                                        <div className="damage-breakdown-container">
+                                            <DamageBreakdown
+                                                breakdown={calculateDamageBreakdown(
+                                                    character,
+                                                    weapon,
+                                                    isTwoHanded,
+                                                    item,
+                                                    character.activeConditionalDamage || []
+                                                )}
+                                                onToggleConditional={toggleConditionalDamage}
+                                            />
+                                        </div>
+                                    )}
+
                                     <div className="weapon-stat-row">
                                         <span className="stat-label">{t('stats.hands') || 'Hands'}:</span>
                                         <span className="stat-value">{weapon.hands}</span>
diff --git a/src/styles/desktop.css b/src/styles/desktop.css
index 0ab1697b..4092a109 100644
--- a/src/styles/desktop.css
+++ b/src/styles/desktop.css
@@ -2340,6 +2340,100 @@
     border-color: var(--desktop-accent-blue);
 }
 
+/* ===== Attack Bonus Display with MAP ===== */
+.attack-info-row {
+    display: flex;
+    align-items: center;
+    justify-content: space-between;
+    margin-bottom: 4px;
+}
+
+.attack-bonus-display {
+    display: flex;
+    align-items: center;
+    gap: 6px;
+}
+
+.attack-bonus-label {
+    font-size: 10px;
+    color: var(--desktop-text-muted);
+    text-transform: uppercase;
+}
+
+.attack-bonus-value {
+    font-size: 14px;
+    font-weight: 700;
+    color: var(--desktop-accent-orange);
+    font-family: var(--font-mono);
+}
+
+.agile-indicator {
+    font-size: 12px;
+    color: var(--desktop-accent-yellow);
+    cursor: help;
+}
+
+/* ===== Attack Buttons ===== */
+.weapon-controls {
+    display: flex;
+    align-items: center;
+    gap: 4px;
+}
+
+.attack-btn {
+    min-width: 28px;
+    height: 28px;
+    padding: 0 6px;
+    background: var(--desktop-bg-tertiary);
+    border: 1px solid var(--desktop-border);
+    border-radius: 4px;
+    color: var(--desktop-text);
+    font-size: 11px;
+    font-weight: 600;
+    cursor: pointer;
+    transition: all 0.2s;
+    display: flex;
+    align-items: center;
+    justify-content: center;
+}
+
+.attack-btn:hover {
+    background: var(--desktop-bg-hover);
+    border-color: var(--desktop-accent-orange);
+    transform: translateY(-1px);
+    box-shadow: 0 2px 8px rgba(255, 165, 0, 0.2);
+}
+
+.attack-btn:active {
+    transform: translateY(0);
+}
+
+.attack-btn.main-attack {
+    border-color: rgba(255, 165, 0, 0.4);
+    background: linear-gradient(135deg, rgba(255, 165, 0, 0.1), transparent);
+}
+
+.attack-btn.main-attack:hover {
+    border-color: var(--desktop-accent-orange);
+    background: linear-gradient(135deg, rgba(255, 165, 0, 0.2), transparent);
+}
+
+.attack-btn.second-attack {
+    border-color: rgba(255, 165, 0, 0.3);
+}
+
+.attack-btn.second-attack:hover {
+    border-color: rgba(255, 165, 0, 0.6);
+}
+
+.attack-btn.third-attack {
+    border-color: rgba(255, 165, 0, 0.2);
+}
+
+.attack-btn.third-attack:hover {
+    border-color: rgba(255, 165, 0, 0.5);
+}
+
 .weapon-stats-section {
     display: grid;
     grid-template-columns: auto 1fr auto;
diff --git a/src/types/character.ts b/src/types/character.ts
index 03bc998a..b5afa02e 100644
--- a/src/types/character.ts
+++ b/src/types/character.ts
@@ -481,6 +481,9 @@ export interface Character {
     conditions: { id: string; value?: number; duration?: number }[];
     buffs: Buff[];
 
+    // Active conditional damage for weapons (rune IDs that are currently active)
+    activeConditionalDamage: string[];
+
     // Resistances & Immunities
     resistances: Resistance[];
     immunities: Immunity[];
@@ -604,6 +607,7 @@ export function createEmptyCharacter(): Character {
         currency: { cp: 0, sp: 0, gp: 15, pp: 0 },
         conditions: [],
         buffs: [],
+        activeConditionalDamage: [],
         resistances: [],
         immunities: [],
         customResources: [],
@@ -725,6 +729,11 @@ export function migrateCharacter(data: any): Character {
         character.archetypeDedications = {};
     }
 
+    // Migrate activeConditionalDamage (added for conditional damage system)
+    if (!character.activeConditionalDamage) {
+        character.activeConditionalDamage = [];
+    }
+
     // Migrate heroPoints (added for interactive hero points)
     if (character.heroPoints === undefined) {
         character.heroPoints = 1;
diff --git a/src/types/dice.ts b/src/types/dice.ts
index c0454863..4d75d888 100644
--- a/src/types/dice.ts
+++ b/src/types/dice.ts
@@ -10,6 +10,8 @@ export interface WeaponRollData {
     attackBonus: number;  // Base attack bonus without MAP
     isTwoHanded: boolean;  // Whether weapon is in two-handed mode
     isAgile: boolean;  // Whether weapon has agile trait (reduced MAP)
+    element?: string;  // Optional: legacy single elemental type (kept for backward compatibility)
+    elementalTypes?: string[];  // Optional: array of elemental types for multi-colored dice (e.g., ['fire', 'cold', 'acid'])
 }
 
 export interface ImpulseRollData {
diff --git a/src/utils/damageBreakdown.ts b/src/utils/damageBreakdown.ts
new file mode 100644
index 00000000..c4308940
--- /dev/null
+++ b/src/utils/damageBreakdown.ts
@@ -0,0 +1,381 @@
+/**
+ * Damage Breakdown Utility
+ * Calculates and displays detailed damage information including base damage, runes, buffs, and conditional damage
+ */
+
+import { Character, EquippedItem, WeaponRunes, WeaponCustomization, Buff } from '../types';
+import { LoadedWeapon } from '../data/pf2e-loader';
+import { getAbilityModifier, ProficiencyRank, calculateProficiencyBonusWithVariant } from './pf2e-math';
+import { calculateActiveModifiers, ModifierBreakdown } from './conditionModifiers';
+import { PROPERTY_RUNES } from '../data/weaponRunes';
+
+export interface DamageComponent {
+    label: string;
+    labelIt?: string;
+    value: string;  // e.g., "1d8", "+3", "2d6 fire"
+    type: 'base' | 'rune-striking' | 'rune-property' | 'ability' | 'buff' | 'conditional';
+    damageType?: string;  // physical, fire, cold, etc.
+    conditionalId?: string;  // ID for conditional damage (for toggle state)
+    isActive?: boolean;  // For conditional damage
+    source?: string;  // Source of the damage (e.g., "Rage", "Flaming Rune")
+}
+
+export interface DamageBreakdown {
+    base: DamageComponent[];  // Base weapon damage
+    runes: DamageComponent[];  // Extra damage from runes (striking, property)
+    modifier: DamageComponent[];  // Static modifiers (STR, custom bonuses)
+    buffs: DamageComponent[];  // Active buffs (rage, etc.)
+    conditional: DamageComponent[];  // Conditional damage (vs specific creatures)
+    total: string;  // Total damage formula
+}
+
+/**
+ * Parse damage dice formula (e.g., "2d6+3" -> {count: 2, size: 6, modifier: 3})
+ */
+export function parseDamageFormula(formula: string): { count: number; size: number; modifier: number } | null {
+    // Match patterns like "2d6+3", "1d8", "3d10-2"
+    const match = formula.match(/^(\d+)d(\d+)([+-]\d+)?$/);
+    if (!match) return null;
+
+    return {
+        count: parseInt(match[1]),
+        size: parseInt(match[2]),
+        modifier: match[3] ? parseInt(match[3]) : 0,
+    };
+}
+
+/**
+ * Calculate detailed damage breakdown for a weapon
+ */
+export function calculateDamageBreakdown(
+    character: Character,
+    weapon: LoadedWeapon,
+    isTwoHanded: boolean = false,
+    equippedItem?: EquippedItem,
+    activeConditionalDamage: string[] = []
+): DamageBreakdown {
+    const strMod = getAbilityModifier(character.abilityScores.str);
+    const dexMod = getAbilityModifier(character.abilityScores.dex);
+
+    // Parse base damage
+    const baseDamageMatch = weapon.damage.match(/^(\d+)d(\d+)$/);
+    if (!baseDamageMatch) {
+        return {
+            base: [],
+            runes: [],
+            modifier: [],
+            buffs: [],
+            conditional: [],
+            total: weapon.damage,
+        };
+    }
+
+    let baseDiceCount = parseInt(baseDamageMatch[1]);
+    let baseDieSize = parseInt(baseDamageMatch[2]);
+    const weaponDamageType = weapon.damageType;
+
+    // Handle Two-Hand trait
+    let actualDieSize = baseDieSize;
+    const twoHandTrait = weapon.traits.find(t => t.startsWith('two-hand-d'));
+    if (isTwoHanded && twoHandTrait) {
+        const twoHandDieMatch = twoHandTrait.match(/two-hand-d(\d+)/);
+        if (twoHandDieMatch) {
+            actualDieSize = parseInt(twoHandDieMatch[1]);
+        }
+    }
+
+    const base: DamageComponent[] = [];
+    const runes: DamageComponent[] = [];
+    const modifier: DamageComponent[] = [];
+    const buffs: DamageComponent[] = [];
+    const conditional: DamageComponent[] = [];
+
+    // ===== BASE DAMAGE =====
+    base.push({
+        label: 'Base Weapon',
+        labelIt: 'Danno Base',
+        value: `${baseDiceCount}d${actualDieSize}`,
+        type: 'base',
+        damageType: weaponDamageType,
+    });
+
+    // ===== STRIKING RUNE =====
+    const weaponRunes = equippedItem?.runes as WeaponRunes | undefined;
+    let strikingBonus = 0;
+
+    if (character.variantRules?.automaticBonusProgression) {
+        // ABP: Use striking bonus from level
+        const abpStriking = Math.floor((character.level || 1) / 6); // Rough approximation
+        strikingBonus = Math.min(abpStriking, 3);
+    } else {
+        const strikingRune = weaponRunes?.strikingRune;
+        if (strikingRune === 'striking') strikingBonus = 1;
+        else if (strikingRune === 'greaterStriking') strikingBonus = 2;
+        else if (strikingRune === 'majorStriking') strikingBonus = 3;
+    }
+
+    if (strikingBonus > 0) {
+        runes.push({
+            label: 'Striking Rune',
+            labelIt: 'Runa Colpitore',
+            value: `+${strikingBonus}d${actualDieSize}`,
+            type: 'rune-striking',
+            damageType: weaponDamageType,
+            source: strikingBonus === 1 ? 'Striking' : strikingBonus === 2 ? 'Greater Striking' : 'Major Striking',
+        });
+        baseDiceCount += strikingBonus;
+    }
+
+    // ===== PROPERTY RUNES (elemental damage) =====
+    const propertyRuneIds = weaponRunes?.propertyRunes || [];
+    for (const runeId of propertyRuneIds) {
+        const runeData = PROPERTY_RUNES[runeId];
+        if (runeData?.damage) {
+            const isActive = activeConditionalDamage.includes(runeId);
+            runes.push({
+                label: runeData.name,
+                labelIt: runeData.nameIt,
+                value: runeData.damage.dice,
+                type: 'rune-property',
+                damageType: runeData.damage.type,
+                conditionalId: runeId,
+                isActive,
+                source: runeData.name,
+            });
+        }
+    }
+
+    // ===== ABILITY MODIFIER =====
+    const isRanged = weapon.range !== null && weapon.range > 0;
+    const hasThrown = weapon.traits.includes('Thrown');
+    const hasPropulsive = weapon.traits.includes('Propulsive');
+
+    let abilityMod = 0;
+    if (isRanged && !hasThrown) {
+        abilityMod = 0;
+        if (hasPropulsive) {
+            abilityMod = Math.floor(strMod / 2);
+            if (abilityMod !== 0) {
+                modifier.push({
+                    label: 'Propulsive (Half STR)',
+                    labelIt: 'Propulsivo (Mezza FOR)',
+                    value: abilityMod > 0 ? `+${abilityMod}` : `${abilityMod}`,
+                    type: 'ability',
+                    damageType: weaponDamageType,
+                });
+            }
+        }
+    } else {
+        abilityMod = strMod;
+        if (abilityMod !== 0) {
+            modifier.push({
+                label: 'Strength',
+                labelIt: 'Forza',
+                value: abilityMod > 0 ? `+${abilityMod}` : `${abilityMod}`,
+                type: 'ability',
+                damageType: weaponDamageType,
+            });
+        }
+    }
+
+    // ===== CUSTOM DAMAGE BONUS =====
+    const weaponCustomization = equippedItem?.customization as WeaponCustomization | undefined;
+    const customDamageBonus = weaponCustomization?.bonusDamage || 0;
+    if (customDamageBonus !== 0) {
+        modifier.push({
+            label: 'Custom Bonus',
+            labelIt: 'Bonus Personalizzato',
+            value: customDamageBonus > 0 ? `+${customDamageBonus}` : `${customDamageBonus}`,
+            type: 'buff',
+            damageType: weaponCustomization?.customDamageType || weaponDamageType,
+        });
+    }
+
+    // ===== BUFFS (e.g., Rage) =====
+    const activeModifiers = calculateActiveModifiers(
+        character.conditions || [],
+        character.buffs || [],
+        character.skills || []
+    );
+
+    const damageBuffs = activeModifiers.damage;
+    if (damageBuffs.total !== 0) {
+        // Break down by type
+        if (damageBuffs.status !== 0) {
+            buffs.push({
+                label: 'Status Bonus',
+                labelIt: 'Bonus di Stato',
+                value: damageBuffs.status > 0 ? `+${damageBuffs.status}` : `${damageBuffs.status}`,
+                type: 'buff',
+                damageType: weaponDamageType,
+            });
+        }
+        if (damageBuffs.circumstance !== 0) {
+            buffs.push({
+                label: 'Circumstance Bonus',
+                labelIt: 'Bonus di Circostanza',
+                value: damageBuffs.circumstance > 0 ? `+${damageBuffs.circumstance}` : `${damageBuffs.circumstance}`,
+                type: 'buff',
+                damageType: weaponDamageType,
+            });
+        }
+        if (damageBuffs.item !== 0) {
+            buffs.push({
+                label: 'Item Bonus',
+                labelIt: 'Bonus di Oggetto',
+                value: damageBuffs.item > 0 ? `+${damageBuffs.item}` : `${damageBuffs.item}`,
+                type: 'buff',
+                damageType: weaponDamageType,
+            });
+        }
+    }
+
+    // ===== CONDITIONAL DAMAGE (vs specific creatures) =====
+    // Add property runes that are conditional (holy vs unholy, etc.)
+    for (const runeId of propertyRuneIds) {
+        const runeData = PROPERTY_RUNES[runeId];
+        if (runeData?.damage && isConditionalDamage(runeData.damage.type)) {
+            const isActive = activeConditionalDamage.includes(runeId);
+            conditional.push({
+                label: `${runeData.name} (${getConditionLabel(runeData.damage.type)})`,
+                labelIt: `${runeData.nameIt || runeData.name} (${getConditionLabelIt(runeData.damage.type)})`,
+                value: runeData.damage.dice,
+                type: 'conditional',
+                damageType: runeData.damage.type,
+                conditionalId: runeId,
+                isActive,
+                source: runeData.name,
+            });
+        }
+    }
+
+    // Calculate total damage formula
+    const totalModifier = abilityMod + customDamageBonus + damageBuffs.total;
+    const totalDice = `${baseDiceCount}d${actualDieSize}`;
+    const total = totalModifier > 0
+        ? `${totalDice} + ${totalModifier}`
+        : totalModifier < 0
+        ? `${totalDice} - ${Math.abs(totalModifier)}`
+        : totalDice;
+
+    return {
+        base,
+        runes,
+        modifier,
+        buffs,
+        conditional,
+        total,
+    };
+}
+
+/**
+ * Check if damage type is conditional (vs specific creatures)
+ */
+function isConditionalDamage(damageType: string): boolean {
+    return ['holy', 'unholy', 'chaotic', 'lawful', 'good', 'evil', 'axiomatic', 'anarchic'].includes(
+        damageType.toLowerCase()
+    );
+}
+
+/**
+ * Get condition label for conditional damage
+ */
+function getConditionLabel(damageType: string): string {
+    const labels: Record<string, string> = {
+        'holy': 'vs unholy',
+        'unholy': 'vs holy',
+        'chaotic': 'vs lawful',
+        'lawful': 'vs chaotic',
+        'axiomatic': 'vs chaotic',
+        'anarchic': 'vs lawful',
+    };
+    return labels[damageType.toLowerCase()] || 'conditional';
+}
+
+/**
+ * Get Italian condition label for conditional damage
+ */
+function getConditionLabelIt(damageType: string): string {
+    const labels: Record<string, string> = {
+        'holy': 'vs non santo',
+        'unholy': 'vs santo',
+        'chaotic': 'vs legale',
+        'lawful': 'vs caotico',
+        'axiomatic': 'vs caotico',
+        'anarchic': 'vs legale',
+    };
+    return labels[damageType.toLowerCase()] || 'condizionale';
+}
+
+/**
+ * Calculate total damage including active conditional damage
+ */
+export function calculateTotalDamageWithConditional(
+    breakdown: DamageBreakdown
+): string {
+    const parts: string[] = [];
+
+    // Collect all active damage components
+    const allComponents = [
+        ...breakdown.base,
+        ...breakdown.runes.filter(r => r.isActive !== false),
+        ...breakdown.modifier,
+        ...breakdown.buffs,
+        ...breakdown.conditional.filter(c => c.isActive),
+    ];
+
+    // Group by damage type
+    const byType: Record<string, { dice: string[]; modifier: number }> = {};
+
+    for (const comp of allComponents) {
+        const type = comp.damageType || 'physical';
+        if (!byType[type]) {
+            byType[type] = { dice: [], modifier: 0 };
+        }
+
+        const parsed = parseDamageFormula(comp.value);
+        if (parsed) {
+            byType[type].dice.push(`${parsed.count}d${parsed.size}`);
+            byType[type].modifier += parsed.modifier;
+        } else if (comp.value.startsWith('+') || comp.value.startsWith('-')) {
+            byType[type].modifier += parseInt(comp.value);
+        }
+    }
+
+    // Build formula strings
+    for (const [type, data] of Object.entries(byType)) {
+        if (data.dice.length > 0) {
+            const totalDice = data.dice.join(' + ');
+            const formula = data.modifier > 0
+                ? `${totalDice} + ${data.modifier}`
+                : data.modifier < 0
+                ? `${totalDice} - ${Math.abs(data.modifier)}`
+                : totalDice;
+            parts.push(type !== 'physical' ? `${formula} ${type}` : formula);
+        }
+    }
+
+    return parts.length > 0 ? parts.join(' + ') : breakdown.total;
+}
+
+/**
+ * Check if weapon has property runes with elemental damage
+ */
+export function hasElementalRunes(runes?: WeaponRunes): boolean {
+    if (!runes?.propertyRunes) return false;
+    return runes.propertyRunes.some(runeId => {
+        const rune = PROPERTY_RUNES[runeId];
+        return rune?.damage && ['fire', 'cold', 'acid', 'electricity', 'sonic', 'force', 'positive', 'negative'].includes(rune.damage.type);
+    });
+}
+
+/**
+ * Check if weapon has conditional damage (vs specific creatures)
+ */
+export function hasConditionalDamage(runes?: WeaponRunes): boolean {
+    if (!runes?.propertyRunes) return false;
+    return runes.propertyRunes.some(runeId => {
+        const rune = PROPERTY_RUNES[runeId];
+        return rune?.damage && isConditionalDamage(rune.damage.type);
+    });
+}
diff --git a/src/utils/weaponCalculations.ts b/src/utils/weaponCalculations.ts
new file mode 100644
index 00000000..e52f422e
--- /dev/null
+++ b/src/utils/weaponCalculations.ts
@@ -0,0 +1,177 @@
+/**
+ * Weapon Calculation Utilities
+ * Optimized functions for weapon attack bonuses, damage, and MAP calculations
+ */
+
+import { Character, EquippedItem, WeaponRunes, WeaponCustomization } from '../types';
+import { LoadedWeapon } from '../data/pf2e-loader';
+import { getAbilityModifier, getWeaponProficiencyRank, calculateProficiencyBonusWithVariant, ProficiencyRank } from './pf2e-math';
+import { calculateWeaponDamage } from './pf2e-math';
+
+/**
+ * Multiple Attack Penalty values
+ */
+export interface MAPValues {
+    first: number;    // First attack: 0
+    second: number;   // Second attack: -5 (-4 for agile)
+    third: number;    // Third attack: -10 (-8 for agile)
+}
+
+/**
+ * Complete weapon stats including MAP
+ */
+export interface WeaponStats {
+    attackBonus: number;
+    damage: string;
+    damageType: string;
+    map: MAPValues;
+    proficiency: {
+        rank: ProficiencyRank;
+        bonus: number;
+    };
+    itemBonus: number;
+    abilityMod: number;
+}
+
+/**
+ * Calculate MAP (Multiple Attack Penalty) for a weapon
+ * Agile weapons have reduced penalty
+ */
+export function calculateMAP(isAgile: boolean): MAPValues {
+    if (isAgile) {
+        return { first: 0, second: -4, third: -8 };
+    }
+    return { first: 0, second: -5, third: -10 };
+}
+
+/**
+ * Calculate attack bonus with MAP penalty
+ */
+export function calculateAttackBonusWithMAP(
+    baseAttackBonus: number,
+    attackNumber: 1 | 2 | 3,
+    map: MAPValues
+): number {
+    const penalty = attackNumber === 1 ? map.first : attackNumber === 2 ? map.second : map.third;
+    return baseAttackBonus + penalty;
+}
+
+/**
+ * Calculate complete weapon stats (memoizable)
+ */
+export function calculateWeaponStats(
+    character: Character,
+    weapon: LoadedWeapon,
+    isTwoHanded: boolean,
+    equippedItem?: EquippedItem
+): WeaponStats {
+    const weaponRunes = equippedItem?.runes as WeaponRunes | undefined;
+    const weaponCustomization = equippedItem?.customization as WeaponCustomization | undefined;
+
+    // Ability modifier
+    const abilityMod = getAbilityModifier(character.abilityScores.str);
+
+    // Proficiency
+    const profRank = getWeaponProficiencyRank(character, weapon.category);
+    const profBonus = calculateProficiencyBonusWithVariant(
+        character.level,
+        profRank,
+        character.variantRules?.proficiencyWithoutLevel
+    );
+
+    // Item bonus from potency rune
+    let itemBonus = 0;
+    if (weaponRunes?.potencyRune) {
+        // potencyRune is a number (1, 2, 3, 4, 5) representing the bonus
+        itemBonus = typeof weaponRunes.potencyRune === 'number'
+            ? weaponRunes.potencyRune
+            : 0;
+    }
+
+    // Custom bonus
+    const customBonus = weaponCustomization?.bonusAttack || 0;
+
+    // Base attack bonus
+    const attackBonus = abilityMod + profBonus + itemBonus + customBonus;
+
+    // MAP values
+    const isAgile = weapon.traits.includes('agile');
+    const map = calculateMAP(isAgile);
+
+    // Damage
+    const damage = calculateWeaponDamage(character, weapon, isTwoHanded, {
+        runes: weaponRunes,
+        customization: weaponCustomization
+    });
+
+    return {
+        attackBonus,
+        damage,
+        damageType: weaponCustomization?.customDamageType || weapon.damageType,
+        map,
+        proficiency: {
+            rank: profRank,
+            bonus: profBonus
+        },
+        itemBonus,
+        abilityMod
+    };
+}
+
+/**
+ * Format attack bonus with MAP (e.g., "+8/+3/-2")
+ */
+export function formatAttackWithMAP(baseBonus: number, map: MAPValues): string {
+    const first = baseBonus >= 0 ? `+${baseBonus}` : `${baseBonus}`;
+    const second = baseBonus + map.second >= 0 ? `+${baseBonus + map.second}` : `${baseBonus + map.second}`;
+    const third = baseBonus + map.third >= 0 ? `+${baseBonus + map.third}` : `${baseBonus + map.third}`;
+    return `${first}/${second}/${third}`;
+}
+
+/**
+ * Check if weapon has two-hand-d* trait
+ */
+export function hasTwoHandTrait(weapon: LoadedWeapon): boolean {
+    return weapon.traits.some(t => t.startsWith('two-hand-d'));
+}
+
+/**
+ * Get weapon type category for display
+ */
+export function getWeaponCategoryLabel(category: string): string {
+    const labels: Record<string, string> = {
+        'simple': 'Simple',
+        'martial': 'Martial',
+        'advanced': 'Advanced',
+        'unarmed': 'Unarmed'
+    };
+    return labels[category] || category;
+}
+
+/**
+ * Get melee/ranged indicator
+ */
+export function getWeaponRangeType(weapon: LoadedWeapon): 'melee' | 'ranged' | 'both' {
+    const hasRange = weapon.range !== null && weapon.range > 0;
+    const hasThrown = weapon.traits.includes('Thrown');
+
+    if (hasRange && !hasThrown) return 'ranged';
+    if (hasThrown) return 'both';
+    return 'melee';
+}
+
+/**
+ * Calculate weapon range increment for thrown weapons
+ */
+export function getWeaponRange(weapon: LoadedWeapon): number | null {
+    if (weapon.range !== null && weapon.range > 0) {
+        return weapon.range;
+    }
+    // Thrown weapons use their range value
+    const thrownTrait = weapon.traits.find(t => t.startsWith('Thrown '));
+    if (thrownTrait) {
+        const match = thrownTrait.match(/Thrown (\d+)/);
+        if (match) return parseInt(match[1]);
+    }
+    return null;
+}
